require 'rubygems'
require 'spec/story'
require File.dirname(__FILE__) + "/../../../lib/adhearsion"
require 'adhearsion/voip/asterisk/new-ami/ami'

RAGEL_FILES = %W[lib/adhearsion/voip/asterisk/new-ami/ami.rl]

def regenerate_ragel
  # Check Ragel version:
  ragel_version_match = `ragel --version`.match(/(\d)\.(\d)+/)
  abort "Could not get Ragel version! Is it installed? You must have at least version 6.3" unless ragel_version_match
  big, small = ragel_version_match.captures.map { |n| n.to_i }
  if big < 6 || (big == 6 && small < 3)
    abort "Please upgrade Ragel! You're on version #{ragel_version_match[0]} and must be on 6.3 or later"
  end
  
  RAGEL_FILES.each do |ragel_file|
    ruby_file  = ragel_file[0..-2] + "b"
    
    # Generate output
    puts `ragel -n -R #{ragel_file} -o #{ruby_file} 2>&1`
    raise if $?.to_i.nonzero?
  
    # comment = '# THIS FILE WAS AUTOMATICALLY GENERATED BY RAGEL. DO NOT MODIFY!'
    # code = File.read(ruby_file).split "\n"
    # File.open ruby_file, "w" do |file|
    #   until code.empty?
    #     file.puts code.shift
    #     file.puts comment
    #   end
    # end
  end
end

FIXTURES = YAML.load_file File.dirname(__FILE__) + "/ami_fixtures.yml"

def fixture(path, overrides={})
  path_segments = path.split '/'
  selected_event = path_segments.inject(FIXTURES.clone) do |hash, segment|
    raise ArgumentError, path + " not found!" unless hash
    hash[segment.to_sym]
  end
  
  # Downcase all keys in the event and the overrides
  selected_event = selected_event.inject({}) do |downcased_hash,(key,value)|
    downcased_hash[key.to_s.downcase] = value
    downcased_hash
  end
  overrides = overrides.inject({}) do |downcased_hash,(key,value)|
    downcased_hash[key.to_s.downcase] = value
    downcased_hash
  end
  
  # Replace variables in the selected_event with any overrides, ignoring case of the key
  keys_with_variables = selected_event.select { |(key, value)| value.kind_of?(Symbol) || value.kind_of?(Hash) }
  
  keys_with_variables.each do |original_key, variable_type|
    # Does an override an exist in the supplied list?
    if overriden_pair = overrides.find { |(key, value)| key == original_key }
      # We have an override! Let's replace the template value in the event with the overriden value
      selected_event[original_key] = overriden_pair.last
    else
      # Based on the type, let's generate a placeholder.
      selected_event[original_key] = case variable_type
        when :string
          rand(100000).to_s
        when Hash
          if variable_type.has_key? "one_of"
            # Choose a random possibility
            possibilities = variable_type['one_of']
            possibilities[rand(possibilities.size)]
          else
            raise "Unrecognized Hash fixture property! ##{variable_type.keys.to_sentence}"
          end
        else
          raise "Unrecognized fixture variable type #{variable_type}!"
      end
    end
    
  end
  returning hash_to_stanza(selected_event) do |event|
    selected_event.each_pair do |key, value|
      event.meta_def(key) { value }
    end
  end
end

def hash_to_stanza(hash)
  ordered_hash = hash.to_a
  starter = hash.find { |(key, value)| key =~ /^(Response|Action)$/i }
  ordered_hash.unshift ordered_hash.delete(starter) if starter
  ordered_hash.inject(String.new) do |stanza,(key, value)|
    stanza + "#{key}: #{value}\r\n"
  end + "\r\n"
end

Dir.chdir(File.dirname(__FILE__) + "/../../..") { regenerate_ragel }

# module ManagerProtocolSpecHelper
#   
#   class NoSyntaxErrors
#     def matches?(_)
#       @syntax_errors.size == 0
#     end
#     
#     def description
#       "have no syntax errors"
#     end
#     
#     def failure_message
#       chunks = @syntax_errors.map { |error| (" " * 4) + error.inspect }.join("\n")
#       " expected to have encountered no SYNTAX errors, but encountered the following unrecognized chunk(s):\n#{chunks}"
#     end
#     
#     def negative_failure_message
#     " expected to have encountered SYNTAX errors but none were found"
#     end
#     
#   end
#   
#   def have_no_syntax_errors
#     NoSyntaxErrors.new
#   end
# end